namespace WalletKit {
};

interface EthereumAddress {
    [Throws=Error]
    constructor(string string);

    string to_string();
};

[Error]
interface Error {
    AlloyError(string description);
    MnemonicError(string description);
    NotImplemented();
    SuiError(string description);
    TrezorError(string description);
};

interface AlloyClient {
    [Throws=Error]
    constructor(u64 chain_id, u64 account_index, sequence<u8> private_key, string? password, string rpc_url);

    [Async, Throws=Error, Name=new_trezor]
    constructor(u64 chain_id, u64 account_index, string device_id, string rpc_url);

    [Throws=Error, Name=new_watch_only]
    constructor(u64 chain_id, EthereumAddress address, string rpc_url);

    EthereumAddress address();

    u64 chain_id();

    string? derivation_path();

    [Async, Throws=Error]
    sequence<u64> get_balance();

    [Async, Throws=Error]
    boolean is_active_address(EthereumAddress address);

    string rpc_url();
};

interface ERC20 {
    [Throws=Error]
    constructor(EthereumAddress address, string rpc_url);

    EthereumAddress address();

    [Async, Throws=Error]
    u8 decimals();

    [Async, Throws=Error]
    string symbol();

    [Async, Throws=Error]
    sequence<u64> balance_of(EthereumAddress owner);
};

interface Mnemonic {
    [Throws=Error, Name=from_seed_phrase]
    constructor(string seed_phrase);

    [Throws=Error, Name=from_entropy]
    constructor(sequence<u8> entropy);

    string seed_phrase();
    sequence<u8> entropy();
};

interface Trezor {
    [Async, Throws=Error]
    constructor();

    string device_id();
    string model();
    string revision();
    string vendor();
};

interface SuiAddress {
    [Throws=Error]
    constructor(string string);

    string to_string();
};

interface SuiClient {
    [Throws=Error]
    constructor(u64 account_index, SignatureScheme key_scheme, sequence<u8> private_key, string? password, string rpc_url);

    [Throws=Error, Name=new_watch_only]
    constructor(SuiAddress address, string rpc_url);

    SuiAddress address();
    string? derivation_path();

    [Async, Throws=Error]
    boolean is_active_address(SuiAddress address);

    [Async, Throws=Error]
    sequence<u64> get_balance(string coin_type);
};

enum SignatureScheme {
    "BLS12381",
    "ED25519",
    "MultiSig",
    "Secp256k1",
    "Secp256r1",
    "ZkLoginAuthenticator",
    "PasskeyAuthenticator",
};